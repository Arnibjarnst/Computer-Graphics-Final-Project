<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

**Homework 3 - Monte Carlo Ray Tracing**

Student Name: Árni Bjarnsteinsson

Legi Number: 21-907-241

(Note: please read the [supplementary](#supplementary) section first before working on this report.)

# Part 1: Light Sampling

## Integrator Implementation
**Time spent on this task: 1.5 hours**

**Describe your implementation of `direct_ems`.**

I start by checking for a ray intersection with the scene and return 0 if none is found.

If the ray intersected with an emitter I evaluate the radiance at the intersection point, Le. (Le is 0 if point is not on an emitter)

I then fetch a random emitter in the scene and sample it (lets call it radiance).

If the sampled point on the emitter is occluded (blocked by something or behind the intersecting plane) I return Le

else I calculate the BSDF  for the intersection point and the two directions and calculate the reflected light which is

$Lr = radiance * bsdf\_value * cos(\theta) * number\_of\_lights\_in\_scene$

$\theta$ is the angle between the shading normal of the intersection and the ray towards the sampled point on the light.

Note that we need to multiply with the number of lights in the scene to account for the pdf in the sampling method of the light only accounts for one light in the scene
but we randomly choose one light so pdf needs to be divided by number of lights, i.e. sampled radiance multiplied by number of lights.

Finally I return $Le + Lr$


## Shape Area Light
**Time spent on this task: 2.5 hours**

**Describe your implementation of `AreaEmitter::eval(...)`.**

eval only checks if the direction is outwards or inwards

if outwards it returns the radiance of the light, else returns 0.

**Describe your implementation of `AreaEmitter::pdf(...)` and `AreaEmitter::sample(...)`.**

Sample:

sample gets a random point on the emitter by sampling the surface, then fills all the fields of the EmitterQueryRecord.

We then reject the sample by returning 0 if our pdf function returns 0 (point on light points away from reference point)

if sample was not rejected we return eval() / pdf()

pdf:

pdf gets the pdf of the shape (1 over the total area of the surface) and returns

$\frac{pdf\_shape * dist\_squared}{cos(\theta)}$

where dist_squared is the distance squared from the reference point to the sampled point on the light

and $\theta$ is the angle between the normal of the sampled point on the light and the direction towards the reference point.

this is done to get the pdf in units of solid angles.

## Validation
**Comparison: sphere/sphere_pointlights_ems**
<div class="twentytwenty-container">
    <img src="images/ref_sphere_pointlights_ems.png" alt="Reference_ems" class="img-responsive">
    <img src="images/sphere_pointlights_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: sphere/sphere_ems**
<div class="twentytwenty-container">
    <img src="images/ref_sphere_ems.png" alt="Reference_ems" class="img-responsive">
    <img src="images/sphere_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: sphere/sphere_mesh_ems**
<div class="twentytwenty-container">
    <img src="images/ref_sphere_mesh_ems.png" alt="Reference_ems" class="img-responsive">
    <img src="images/sphere_mesh_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: sphere/sphere2_ems**
<div class="twentytwenty-container">
    <img src="images/ref_sphere2_ems.png" alt="Reference_ems" class="img-responsive">
    <img src="images/sphere2_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: sphere/sphere2_mesh_ems**
<div class="twentytwenty-container">
    <img src="images/ref_sphere2_mesh_ems.png" alt="Reference_ems" class="img-responsive">
    <img src="images/sphere2_mesh_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: odyssey_ems**
<div class="twentytwenty-container">
    <img src="images/ref_odyssey_ems_64spp.png" alt="Reference_ems" class="img-responsive">
    <img src="images/odyssey_ems.png" alt="Mine_ems" class="img-responsive">
</div>

**Comparison: veach_ems**
<div class="twentytwenty-container">
    <img src="images/ref_veach_ems_256spp.png" alt="Reference_ems" class="img-responsive">
    <img src="images/veach_ems.png" alt="Mine_ems" class="img-responsive">
</div>

# Part 2: BRDF Sampling

## Integrator Implementation
**Time spent on this task: 1-2 hour**

**Describe your implementation of `direct_mats`.**

I start by checking for a ray intersection with the scene and return 0 if none is found.

If the ray intersected with an emitter I evaluate the radiance at the intersection point, Le. (Le is 0 if point is not on an emitter)

I then sample the BRDF of the intersection´s mesh using the ray I shot in the shading frame of the intersection point (get brdf_value).

If the reflected direction goes into the mesh I return Le (we are only dealing with a BRDF not a BSDF/BTDF but this might need changing)

I then shoot a ray in the BRDF direction and if it does not hit an emitter I return Le

else I evaluate the radiance at that point on the emitter and return

$Le + brdf\_value * radiance$

Note that there is no cosine value here because it is in the brdf_value


## Microfacet BRDF
**Time spent on this task: 4+ hours**

**Describe your implementation of `Microfacet::eval(...)`.**

I just return the value specified in the instructions

**Describe your implementation of `Microfacet::sample(...)`.**

First I check if w_i goes into the surface, if so I return 0;

Then I check if _sample.x is below ks I sample according to the microfacet distribution.

To do that I need to put _sample.x back to [0;1[ which I do by creating $sample = (\frac{sample.x}{ks}, sample.y)$

then I warp sample to Beckmann to get w_h and reflect w_i around w_h to get the scattering direction w_o.

If w_o goes into the surface I return 0

if _sample.x was not below ks then I sample according to a cosine weighted hemispherical sampling.

To do that I first also have to put _sample.x back to [0;1[ which I do by $sample = (\frac{sample.x - ks}{1 - ks}, sample.y)$

then I warp my sample to a cosine weighted hemispherical sample to get the scattering direction w_o

Finally I return $cos(\theta_o) \frac{eval()}{pdf()}$ for that w_i and w_o ($\theta_o$ is the angle between w_o and the surface normal)

## Validation
**Comparison: sphere/sphere_mats**
<div class="twentytwenty-container">
    <img src="images/ref_sphere_mats.png" alt="Reference_mats" class="img-responsive">
    <img src="images/sphere_mats.png" alt="Mine_mats" class="img-responsive">
</div>

**Comparison: sphere/sphere2_mats**
<div class="twentytwenty-container">
    <img src="images/ref_sphere2_mats.png" alt="Reference_mats" class="img-responsive">
    <img src="images/sphere2_mats.png" alt="Mine_mats" class="img-responsive">
</div>

**Comparison: odyssey_mats**
<div class="twentytwenty-container">
    <img src="images/ref_odyssey_mats_64spp.png" alt="Reference_mats" class="img-responsive">
    <img src="images/odyssey_mats.png" alt="Mine_mats" class="img-responsive">
</div>

**Comparison: veach_mats**
<div class="twentytwenty-container">
    <img src="images/ref_veach_mats_256spp.png" alt="Reference_mats" class="img-responsive">
    <img src="images/veach_mats.png" alt="Mine_mats" class="img-responsive">
</div>

# Part 3: Multiple Importance Sampling
## Integrator Implementation
**Time spent on this task: 1-2 hours**

**Describe your implementation of `direct_mis`.**

Here I start like the two other integrators by checking for a ray intersection with the scene and return 0 if none is found.

If the ray intersected with an emitter I evaluate the radiance at the intersection point, Le. (Le = 0 if point is not on an emitter)

Then I calculate the other parts just like I did in the other integrators except I have to multiply their value by a value to fix their pdf functions

For the area sampling:

$W_{em} = \frac{pdf_{emitter}}{\frac{pdf_{emitter}}{N_{em}} + pdf_{bsdf}}$

N_em = number of emitters in the scene

Note that I only divide the pdf of the emitter by $N_{em}$ in the denominator so I can avoid multiplying the radiance by $N_{em}$

For the BSDF:

$W_{mat} = \frac{pdf_{bsdf}}{pdf_{bsdf} + \frac{pdf_{emitter}}{N_{em}}}$

Then I return $L_e + W_{em} * L_{em} + W_{mat} * L_{mat}$

## Validation
**Comparison: odyssey_mis**
<div class="twentytwenty-container">
    <img src="images/ref_odyssey_mis_32spp.png" alt="Reference_mis" class="img-responsive">
    <img src="images/odyssey_mis.png" alt="Mine_mis" class="img-responsive">
</div>

**Comparison: veach_mis**
<div class="twentytwenty-container">
    <img src="images/ref_veach_mis_128spp.png" alt="Reference_mis" class="img-responsive">
    <img src="images/veach_mis.png" alt="Mine_mis" class="img-responsive">
</div>

# Part 4: Four-way Comparison
**Odyssey**
<div class="twentytwenty-container">
    <img src="images/ref_odyssey_mis_32spp.png" alt="Reference_mis" class="img-responsive">
    <img src="images/odyssey_ems.png" alt="Mine_ems" class="img-responsive">
    <img src="images/odyssey_mats.png" alt="Mine_mats" class="img-responsive">
    <img src="images/odyssey_mis.png" alt="Mine_mis" class="img-responsive">
</div>

**Veach**
<div class="twentytwenty-container">
    <img src="images/ref_veach_mis_128spp.png" alt="Reference_mis" class="img-responsive">
    <img src="images/veach_ems.png" alt="Mine_ems" class="img-responsive">
    <img src="images/veach_mats.png" alt="Mine_mats" class="img-responsive">
    <img src="images/veach_mis.png" alt="Mine_mis" class="img-responsive">
</div>




# Feedback
**Use this section to provide feedback about this assignment (each task, the handout, Nori, etc.). We appreciate your opinions to help improve future homeworks and projects.**

...


# Supplementary
* For each task, please note down the time you spent working through it and use at least a few sentences to describe your implementation. If applicable, also report the problems you encounter (e.g. whether or how it's solved, what is the difficult part).

* Please let us know to what extent your code is working (e.g. you only managed to work through part of this assignment, or your solution doesn't operate as expected in some corner cases). We encourage you to share your thinking process, and points will be granted based on your description even if the code is not 100% functioning.

* Nori generates both EXR and PNG format output. Please use PNG for image comparison in the report.

* This report template uses [Markdeep](https://casual-effects.com/markdeep/), which supports Markdown syntax in HTML file. For example usage, please refer to the [official demo document](https://casual-effects.com/markdeep/features.md.html).

* LaTeX is also supported for typing mathematical formulas:
$$
L_o(\mathbf{x}, \omega_o) = \int_{\Omega} L_i(\mathbf{x},\omega_i)\, f(\mathbf{x}, \omega_i, \omega_o)\, |\cos\theta_i|\, \mathrm{d}\omega_i
$$



<!-- Bootstrap core CSS and JavaScript -->

<link href="../resources/offcanvas.css" rel="stylesheet">
<link href="../resources/twentytwenty.css" rel="stylesheet" type="text/css" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="../resources/bootstrap.min.js"></script>
<script src="../resources/jquery.event.move.js"></script>
<script src="../resources/jquery.twentytwenty.js"></script>

<script>
    $(window).load(function () { $(".twentytwenty-container").twentytwenty({ default_offset_pct: 0.5 }); });
</script>

<!-- Markdeep: -->
<script>var markdeepOptions = { onLoad: function () { $(".twentytwenty-container").twentytwenty({ default_offset_pct: 0.5, move_slider_on_hover: true }); }, tocStyle: 'none' };</script>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep || (document.body.style.visibility = "visible")</script>
